using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using Microsoft.Build.Logging.StructuredLogger;
using Xunit;

namespace Microsoft.Build.Logging.StructuredLogger.UnitTests
{
    /// <summary>
    /// Unit tests for the <see cref="TreeBinaryReader"/> class.
    /// </summary>
    public class TreeBinaryReaderTests
    {
        private const byte ValidMajorVersion = 1;
        private const byte ValidMinorVersion = 0;
        private const byte ValidBuildVersion = 0;
        private const byte InvalidMajorVersion = 3; // unsupported because valid major must be 1 or 2

        /// <summary>
        /// Creates a gzip payload as byte array. The payload is generated by compressing data written by a BinaryWriter.
        /// The payload includes an int32 representing the count of strings followed by that many strings.
        /// Optionally, additional payload can be written via the writeAdditionalData action.
        /// </summary>
        /// <param name="tableCount">Number of strings in the string table.</param>
        /// <param name="stringTable">The string table.</param>
        /// <param name="writeAdditionalData">Action to write additional payload data after the string table.</param>
        /// <returns>Byte array containing the gzip-compressed payload data.</returns>
        private static byte[] CreateGzipPayload(int tableCount, string[] stringTable, Action<BinaryWriter> writeAdditionalData = null)
        {
            using (var ms = new MemoryStream())
            {
                // leave the stream open to extract byte array later
                using (var gzip = new GZipStream(ms, CompressionMode.Compress, true))
                using (var writer = new BinaryWriter(gzip, Encoding.UTF8, true))
                {
                    writer.Write(tableCount);
                    foreach (var s in stringTable)
                    {
                        writer.Write(s);
                    }
                    writeAdditionalData?.Invoke(writer);
                }
                return ms.ToArray();
            }
        }

        /// <summary>
        /// Creates a MemoryStream for constructors that expect version bytes at the beginning.
        /// It writes three version bytes followed by the provided gzip payload.
        /// </summary>
        /// <param name="major">Major version byte.</param>
        /// <param name="minor">Minor version byte.</param>
        /// <param name="build">Build version byte.</param>
        /// <param name="gzipPayload">Gzip payload byte array.</param>
        /// <returns>A MemoryStream representing the full file content.</returns>
        private static MemoryStream CreateStreamWithVersionBytes(byte major, byte minor, byte build, byte[] gzipPayload)
        {
            var ms = new MemoryStream();
            ms.WriteByte(major);
            ms.WriteByte(minor);
            ms.WriteByte(build);
            ms.Write(gzipPayload, 0, gzipPayload.Length);
            ms.Position = 0;
            return ms;
        }

        /// <summary>
        /// Creates a MemoryStream for constructors that take an explicit Version parameter.
        /// The stream content is just the gzip payload.
        /// </summary>
        /// <param name="gzipPayload">Gzip payload byte array.</param>
        /// <returns>A MemoryStream representing the gzip payload.</returns>
        private static MemoryStream CreateStreamWithoutVersionBytes(byte[] gzipPayload)
        {
            return new MemoryStream(gzipPayload);
        }

        /// <summary>
        /// Tests that the constructor using a Stream with valid version bytes and payload initializes the reader correctly.
        /// </summary>
        [Fact]
        public void Constructor_Stream_ValidPayload_ShouldInitialize()
        {
            // Arrange
            string[] expectedStringTable = { "table1", "table2" };
            byte[] gzipPayload = CreateGzipPayload(expectedStringTable.Length, expectedStringTable);
            using (var stream = CreateStreamWithVersionBytes(ValidMajorVersion, ValidMinorVersion, ValidBuildVersion, gzipPayload))
            {
                // Act
                var reader = new TreeBinaryReader(stream);

                // Assert
                Assert.True(reader.IsValid());
                Assert.Equal(new Version(ValidMajorVersion, ValidMinorVersion, ValidBuildVersion, 0), reader.Version);
                Assert.Equal(expectedStringTable, reader.StringTable);
                reader.Dispose();
            }
        }

        /// <summary>
        /// Tests that the constructor using a Stream with length less than 8 bytes does not initialize a valid reader.
        /// </summary>
        [Fact]
        public void Constructor_Stream_InvalidShortStream_ShouldNotInitialize()
        {
            // Arrange
            byte[] shortData = new byte[5];
            using (var stream = new MemoryStream(shortData))
            {
                // Act
                var reader = new TreeBinaryReader(stream);

                // Assert
                Assert.False(reader.IsValid());
            }
        }

        /// <summary>
        /// Tests that the constructor using a Stream with an unsupported version (major version not 1 or 2) does not initialize a valid reader.
        /// </summary>
        [Fact]
        public void Constructor_Stream_UnsupportedVersion_ShouldNotInitialize()
        {
            // Arrange
            string[] expectedStringTable = { "dummy" };
            byte[] gzipPayload = CreateGzipPayload(expectedStringTable.Length, expectedStringTable);
            using (var stream = CreateStreamWithVersionBytes(InvalidMajorVersion, ValidMinorVersion, ValidBuildVersion, gzipPayload))
            {
                // Act
                var reader = new TreeBinaryReader(stream);

                // Assert
                Assert.False(reader.IsValid());
            }
        }

        /// <summary>
        /// Tests that the constructor using a Stream with an explicit Version parameter initializes correctly,
        /// ignoring version bytes in the stream.
        /// </summary>
        [Fact]
        public void Constructor_Stream_WithVersionParameter_ValidPayload_ShouldInitialize()
        {
            // Arrange
            string[] expectedStringTable = { "onlyEntry" };
            byte[] gzipPayload = CreateGzipPayload(expectedStringTable.Length, expectedStringTable);
            Version providedVersion = new Version(1, 2, 3);
            using (var stream = CreateStreamWithoutVersionBytes(gzipPayload))
            {
                // Act
                var reader = new TreeBinaryReader(stream, providedVersion);

                // Assert
                Assert.True(reader.IsValid());
                // Provided version should be used.
                Assert.Equal(new Version(providedVersion.Major, providedVersion.Minor, providedVersion.Build, 0), reader.Version);
                Assert.Equal(expectedStringTable, reader.StringTable);
                reader.Dispose();
            }
        }

        /// <summary>
        /// Tests that the constructor using a file path with valid payload initializes the reader correctly.
        /// </summary>
        [Fact]
        public void Constructor_FilePath_ValidPayload_ShouldInitialize()
        {
            // Arrange
            string[] expectedStringTable = { "fileEntry1", "fileEntry2" };
            byte[] gzipPayload = CreateGzipPayload(expectedStringTable.Length, expectedStringTable);
            using (var stream = CreateStreamWithVersionBytes(ValidMajorVersion, ValidMinorVersion, ValidBuildVersion, gzipPayload))
            {
                // Write to a temporary file
                string tempFilePath = Path.GetTempFileName();
                try
                {
                    File.WriteAllBytes(tempFilePath, stream.ToArray());
                    // Act
                    using (var reader = new TreeBinaryReader(tempFilePath))
                    {
                        // Assert
                        Assert.True(reader.IsValid());
                        Assert.Equal(new Version(ValidMajorVersion, ValidMinorVersion, ValidBuildVersion, 0), reader.Version);
                        Assert.Equal(expectedStringTable, reader.StringTable);
                    }
                }
                finally
                {
                    if (File.Exists(tempFilePath))
                    {
                        File.Delete(tempFilePath);
                    }
                }
            }
        }

        /// <summary>
        /// Tests that the ReadByteArray method returns the correct byte array when valid byte array data is present.
        /// </summary>
        [Fact]
        public void ReadByteArray_ValidData_ReturnsByteArray()
        {
            // Arrange
            string[] dummyTable = { "dummy" };
            // Additional payload: write int32 length and then that many bytes.
            Action<BinaryWriter> additionalData = writer =>
            {
                writer.Write(3); // length
                writer.Write(new byte[] { 1, 2, 3 });
            };
            byte[] gzipPayload = CreateGzipPayload(dummyTable.Length, dummyTable, additionalData);
            using (var stream = CreateStreamWithVersionBytes(ValidMajorVersion, ValidMinorVersion, ValidBuildVersion, gzipPayload))
            {
                var reader = new TreeBinaryReader(stream);
                // Act
                byte[] result = reader.ReadByteArray();

                // Assert
                Assert.NotNull(result);
                Assert.Equal(new byte[] { 1, 2, 3 }, result);
                reader.Dispose();
            }
        }

        /// <summary>
        /// Tests that the ReadByteArray method returns null when the length read is not positive.
        /// </summary>
        [Fact]
        public void ReadByteArray_NonPositiveLength_ReturnsNull()
        {
            // Arrange
            string[] dummyTable = { "dummy" };
            Action<BinaryWriter> additionalData = writer =>
            {
                writer.Write(0); // length zero
            };
            byte[] gzipPayload = CreateGzipPayload(dummyTable.Length, dummyTable, additionalData);
            using (var stream = CreateStreamWithVersionBytes(ValidMajorVersion, ValidMinorVersion, ValidBuildVersion, gzipPayload))
            {
                var reader = new TreeBinaryReader(stream);
                // Act
                byte[] result = reader.ReadByteArray();

                // Assert
                Assert.Null(result);
                reader.Dispose();
            }
        }

        /// <summary>
        /// Tests that the ReadInt32 method correctly reads and returns an int32 value from the stream.
        /// </summary>
        [Fact]
        public void ReadInt32_ReturnsCorrectValue()
        {
            // Arrange
            string[] dummyTable = { "dummy" };
            int expectedValue = 42;
            Action<BinaryWriter> additionalData = writer =>
            {
                writer.Write(expectedValue);
            };
            byte[] gzipPayload = CreateGzipPayload(dummyTable.Length, dummyTable, additionalData);
            using (var stream = CreateStreamWithVersionBytes(ValidMajorVersion, ValidMinorVersion, ValidBuildVersion, gzipPayload))
            {
                var reader = new TreeBinaryReader(stream);
                // Act
                int result = reader.ReadInt32();

                // Assert
                Assert.Equal(expectedValue, result);
                reader.Dispose();
            }
        }

        /// <summary>
        /// Tests that the ReadString method returns the correct string based on the index read from the stream.
        /// </summary>
        [Fact]
        public void ReadString_ReturnsCorrectString()
        {
            // Arrange
            string[] expectedTable = { "hello", "world" };
            // Write additional payload: write an int32 index (1 => "hello")
            Action<BinaryWriter> additionalData = writer =>
            {
                writer.Write(1);
            };
            byte[] gzipPayload = CreateGzipPayload(expectedTable.Length, expectedTable, additionalData);
            using (var stream = CreateStreamWithVersionBytes(ValidMajorVersion, ValidMinorVersion, ValidBuildVersion, gzipPayload))
            {
                var reader = new TreeBinaryReader(stream);
                // Act
                string result = reader.ReadString();

                // Assert
                Assert.Equal("hello", result);
                reader.Dispose();
            }
        }

        /// <summary>
        /// Tests that the ReadStringArray method correctly enqueues the strings based on indices read from the stream.
        /// </summary>
        [Fact]
        public void ReadStringArray_ReturnsCorrectStrings()
        {
            // Arrange
            string[] expectedTable = { "first", "second" };
            // Additional payload: first write count (2) then two indices: 2 and 0. (2-> "second", 0-> null)
            Action<BinaryWriter> additionalData = writer =>
            {
                writer.Write(2); // count for string array
                writer.Write(2); // index corresponding to "second"
                writer.Write(0); // index corresponding to null
            };
            byte[] gzipPayload = CreateGzipPayload(expectedTable.Length, expectedTable, additionalData);
            using (var stream = CreateStreamWithVersionBytes(ValidMajorVersion, ValidMinorVersion, ValidBuildVersion, gzipPayload))
            {
                var reader = new TreeBinaryReader(stream);
                Queue<string> resultQueue = new Queue<string>();

                // Act
                reader.ReadStringArray(resultQueue);

                // Assert
                Assert.Equal(2, resultQueue.Count);
                Assert.Equal("second", resultQueue.Dequeue());
                Assert.Null(resultQueue.Dequeue());
                reader.Dispose();
            }
        }

        /// <summary>
        /// Tests that calling Dispose multiple times does not throw exceptions and releases resources.
        /// </summary>
//         [Fact] [Error] (353-33)CS0117 'Record' does not contain a definition for 'Exception'
//         public void Dispose_CalledMultipleTimes_NoException()
//         {
//             // Arrange
//             string[] expectedTable = { "disposeTest" };
//             byte[] gzipPayload = CreateGzipPayload(expectedTable.Length, expectedTable);
//             using (var stream = CreateStreamWithVersionBytes(ValidMajorVersion, ValidMinorVersion, ValidBuildVersion, gzipPayload))
//             {
//                 var reader = new TreeBinaryReader(stream);
// 
//                 // Act & Assert
//                 reader.Dispose();
//                 // Calling Dispose again should not throw.
//                 var ex = Record.Exception(() => reader.Dispose());
//                 Assert.Null(ex);
//             }
//         }

        /// <summary>
        /// Tests that when the gzip payload data is invalid (corrupted gzip stream), the reader is not valid.
        /// </summary>
        [Fact]
        public void Constructor_Stream_InvalidGzipData_ShouldResultInInvalidReader()
        {
            // Arrange
            // Create invalid gzip payload (not actually compressed data)
            byte[] invalidGzip = Encoding.UTF8.GetBytes("NotAGzipData");
            using (var stream = CreateStreamWithVersionBytes(ValidMajorVersion, ValidMinorVersion, ValidBuildVersion, invalidGzip))
            {
                // Act
                var reader = new TreeBinaryReader(stream);

                // Assert
                Assert.False(reader.IsValid());
            }
        }
    }
}
