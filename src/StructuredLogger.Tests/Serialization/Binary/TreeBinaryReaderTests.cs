using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;
using Microsoft.Build.Logging.StructuredLogger;
using Xunit;

namespace Microsoft.Build.Logging.StructuredLogger.UnitTests
{
    /// <summary>
    /// Unit tests for the <see cref="TreeBinaryReader"/> class.
    /// </summary>
    public class TreeBinaryReaderTests
    {
        private const byte ValidMajor = 1;
        private const byte ValidMinor = 2;
        private const byte ValidBuild = 3;
        private static readonly string[] DefaultStringTable = new[] { "first", "second" };

        /// <summary>
        /// Creates a test stream containing a header and a GZip-compressed payload.
        /// The payload is generated by writing the string table and then invoking the extraPayload action.
        /// </summary>
        /// <param name="major">The major version byte.</param>
        /// <param name="minor">The minor version byte.</param>
        /// <param name="build">The build version byte.</param>
        /// <param name="stringTable">The string table to write into the payload.</param>
        /// <param name="extraPayload">An optional action to write additional payload after the string table.</param>
        /// <returns>A MemoryStream containing the constructed test data.</returns>
        private static MemoryStream CreateTestStream(byte major, byte minor, byte build, string[] stringTable, Action<BinaryWriter> extraPayload = null)
        {
            // Outer stream: will contain header and then GZip-compressed payload.
            var outerStream = new MemoryStream();
            // Write header: 3 bytes.
            outerStream.WriteByte(major);
            outerStream.WriteByte(minor);
            outerStream.WriteByte(build);

            // Prepare payload in a separate memory stream.
            var payloadStream = new MemoryStream();
            using (var writer = new BinaryWriter(payloadStream, Encoding.UTF8, leaveOpen: true))
            {
                // Write the string table count.
                writer.Write(stringTable.Length);
                // Write each string in the table.
                foreach (var s in stringTable)
                {
                    writer.Write(s);
                }
                // Invoke extra payload writing if provided.
                extraPayload?.Invoke(writer);
            }
            // Get payload bytes.
            byte[] payloadBytes = payloadStream.ToArray();

            // Compress payload.
            using (var compressedStream = new MemoryStream())
            {
                using (var gzip = new GZipStream(compressedStream, CompressionMode.Compress, leaveOpen: true))
                {
                    gzip.Write(payloadBytes, 0, payloadBytes.Length);
                }
                // Write compressed payload to outer stream.
                byte[] compressedPayload = compressedStream.ToArray();
                outerStream.Write(compressedPayload, 0, compressedPayload.Length);
            }

            outerStream.Position = 0;
            return outerStream;
        }

        /// <summary>
        /// Tests that the constructor properly initializes the TreeBinaryReader using a valid stream.
        /// Expected outcome: The Version, StringTable, and IsValid values are set correctly.
        /// </summary>
        [Fact]
        public void Constructor_WithValidStream_SetsVersionAndStringTable()
        {
            // Arrange
            var testStream = CreateTestStream(ValidMajor, ValidMinor, ValidBuild, DefaultStringTable);

            // Act
            using var reader = new TreeBinaryReader(testStream);

            // Assert
            Assert.True(reader.IsValid());
            Assert.Equal(new Version(ValidMajor, ValidMinor, ValidBuild, 0), reader.Version);
            Assert.Equal(DefaultStringTable, reader.StringTable);
        }

        /// <summary>
        /// Tests that the constructor returns an invalid reader when the stream is too short.
        /// Expected outcome: The reader is not valid.
        /// </summary>
        [Fact]
        public void Constructor_WithShortStream_IsInvalid()
        {
            // Arrange
            byte[] insufficientBytes = new byte[7];
            var shortStream = new MemoryStream(insufficientBytes);

            // Act
            using var reader = new TreeBinaryReader(shortStream);

            // Assert
            Assert.False(reader.IsValid());
        }

        /// <summary>
        /// Tests that the constructor returns an invalid reader when the major version is out of supported range.
        /// Expected outcome: The reader is not valid.
        /// </summary>
        [Fact]
        public void Constructor_WithInvalidMajorVersion_IsInvalid()
        {
            // Arrange
            // Major version set to 3 which is out of accepted range [1,2]
            var testStream = CreateTestStream(3, ValidMinor, ValidBuild, DefaultStringTable);

            // Act
            using var reader = new TreeBinaryReader(testStream);

            // Assert
            Assert.False(reader.IsValid());
        }

        /// <summary>
        /// Tests exception handling by the constructor when the GZip payload is invalid.
        /// Expected outcome: The reader becomes invalid.
        /// </summary>
        [Fact]
        public void Constructor_WithCorruptedGZipPayload_IsInvalid()
        {
            // Arrange
            // Create a stream with proper header but invalid compressed payload.
            var outerStream = new MemoryStream();
            outerStream.WriteByte(ValidMajor);
            outerStream.WriteByte(ValidMinor);
            outerStream.WriteByte(ValidBuild);
            // Write invalid (non-GZip) data.
            var invalidData = Encoding.UTF8.GetBytes("invalid gzip data");
            outerStream.Write(invalidData, 0, invalidData.Length);
            outerStream.Position = 0;

            // Act
            using var reader = new TreeBinaryReader(outerStream);

            // Assert
            Assert.False(reader.IsValid());
        }

        /// <summary>
        /// Tests that the constructor using the overload with an explicit version parameter sets the Version property correctly.
        /// Expected outcome: The Version property matches the provided version parameter.
        /// </summary>
        [Fact]
        public void Constructor_WithExplicitVersion_SetsVersionCorrectly()
        {
            // Arrange
            var explicitVersion = new Version(5, 6, 7, 0);
            var testStream = CreateTestStream(0, 0, 0, DefaultStringTable); // header bytes will be ignored because version is provided

            // Act
            using var reader = new TreeBinaryReader(testStream, explicitVersion);

            // Assert
            Assert.True(reader.IsValid());
            Assert.Equal(explicitVersion, reader.Version);
        }

        /// <summary>
        /// Tests the ReadByteArray method for a valid byte array.
        /// Expected outcome: The method returns the correct byte array.
        /// </summary>
        [Fact]
        public void ReadByteArray_WhenLengthPositive_ReturnsByteArray()
        {
            // Arrange
            byte[] expectedBytes = new byte[] { 10, 20, 30 };
            void ExtraPayload(BinaryWriter writer)
            {
                // Write length and then bytes.
                writer.Write(expectedBytes.Length);
                writer.Write(expectedBytes);
            }
            var testStream = CreateTestStream(ValidMajor, ValidMinor, ValidBuild, DefaultStringTable, ExtraPayload);
            using var reader = new TreeBinaryReader(testStream);

            // Act
            byte[] actualBytes = reader.ReadByteArray();

            // Assert
            Assert.NotNull(actualBytes);
            Assert.Equal(expectedBytes, actualBytes);
        }

        /// <summary>
        /// Tests the ReadByteArray method when the length is non-positive.
        /// Expected outcome: The method returns null.
        /// </summary>
        [Fact]
        public void ReadByteArray_WhenLengthNonPositive_ReturnsNull()
        {
            // Arrange
            void ExtraPayload(BinaryWriter writer)
            {
                // Write a length of 0.
                writer.Write(0);
            }
            var testStream = CreateTestStream(ValidMajor, ValidMinor, ValidBuild, DefaultStringTable, ExtraPayload);
            using var reader = new TreeBinaryReader(testStream);

            // Act
            byte[] actualBytes = reader.ReadByteArray();

            // Assert
            Assert.Null(actualBytes);
        }

        /// <summary>
        /// Tests the ReadInt32 method to ensure it returns the correct integer value.
        /// Expected outcome: The method returns the integer value that was written.
        /// </summary>
        [Fact]
        public void ReadInt32_ReturnsCorrectInteger()
        {
            // Arrange
            const int expectedValue = 42;
            void ExtraPayload(BinaryWriter writer)
            {
                writer.Write(expectedValue);
            }
            var testStream = CreateTestStream(ValidMajor, ValidMinor, ValidBuild, DefaultStringTable, ExtraPayload);
            using var reader = new TreeBinaryReader(testStream);

            // Act
            int actualValue = reader.ReadInt32();

            // Assert
            Assert.Equal(expectedValue, actualValue);
        }

        /// <summary>
        /// Tests the ReadString method when the index refers to a valid string in the string table.
        /// Expected outcome: The method returns the corresponding string.
        /// </summary>
        [Fact]
        public void ReadString_WithValidIndex_ReturnsCorrectString()
        {
            // Arrange
            // Use a string table with two elements.
            string[] stringTable = new[] { "hello", "world" };
            // Extra payload writes an int32 index referencing the second element.
            void ExtraPayload(BinaryWriter writer)
            {
                writer.Write(2); // index 2 should return "world"
            }
            var testStream = CreateTestStream(ValidMajor, ValidMinor, ValidBuild, stringTable, ExtraPayload);
            using var reader = new TreeBinaryReader(testStream);

            // Act
            string actualString = reader.ReadString();

            // Assert
            Assert.Equal("world", actualString);
        }

        /// <summary>
        /// Tests the ReadString method when the index is zero.
        /// Expected outcome: The method returns null.
        /// </summary>
        [Fact]
        public void ReadString_WithZeroIndex_ReturnsNull()
        {
            // Arrange
            void ExtraPayload(BinaryWriter writer)
            {
                writer.Write(0); // zero index should return null
            }
            var testStream = CreateTestStream(ValidMajor, ValidMinor, ValidBuild, DefaultStringTable, ExtraPayload);
            using var reader = new TreeBinaryReader(testStream);

            // Act
            string actualString = reader.ReadString();

            // Assert
            Assert.Null(actualString);
        }

        /// <summary>
        /// Tests the ReadStringArray method to ensure it correctly enqueues strings based on the indices written.
        /// Expected outcome: The method enqueues the correct set of strings.
        /// </summary>
        [Fact]
        public void ReadStringArray_WithMultipleIndices_EnqueuesCorrectStrings()
        {
            // Arrange
            // Use a string table with three elements.
            string[] stringTable = new[] { "a", "b", "c" };
            void ExtraPayload(BinaryWriter writer)
            {
                // Write count of indices.
                writer.Write(3);
                // Write indices: 1, 0, 3 => should result in "a", null, "c"
                writer.Write(1);
                writer.Write(0);
                writer.Write(3);
            }
            var testStream = CreateTestStream(ValidMajor, ValidMinor, ValidBuild, stringTable, ExtraPayload);
            using var reader = new TreeBinaryReader(testStream);
            var queue = new Queue<string>();

            // Act
            reader.ReadStringArray(queue);
            var result = queue.ToArray();

            // Assert
            Assert.Equal(3, result.Length);
            Assert.Equal("a", result[0]);
            Assert.Null(result[1]);
            Assert.Equal("c", result[2]);
        }

        /// <summary>
        /// Tests the Dispose method to ensure that resources are properly released.
        /// Expected outcome: After disposing, the reader becomes invalid.
        /// </summary>
        [Fact]
        public void Dispose_AfterCalling_IsInvalid()
        {
            // Arrange
            var testStream = CreateTestStream(ValidMajor, ValidMinor, ValidBuild, DefaultStringTable);
            var reader = new TreeBinaryReader(testStream);
            Assert.True(reader.IsValid());

            // Act
            reader.Dispose();

            // Assert
            Assert.False(reader.IsValid());
        }
    }
}
